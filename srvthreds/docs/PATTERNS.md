# Pattern Documentation

## Table of Contents
1. [Introduction](#introduction)
2. [Core Concepts](#core-concepts)
3. [Pattern Structure](#pattern-structure)
4. [Reactions](#reactions)
5. [Conditions](#conditions)
6. [Transforms](#transforms)
7. [Publish](#publish)
8. [Transitions](#transitions)
9. [JSONata Expressions](#jsonata-expressions)
10. [Event Tasks](#event-tasks)
11. [Interaction Templates](#interaction-templates)
12. [Authorization](#authorization)
13. [State Management](#state-management)
14. [Complete Examples](#complete-examples)
15. [Best Practices](#best-practices)
16. [AI Agent Guidelines](#ai-agent-guidelines)

---

## Introduction

**Patterns** are JSON-based workflow definitions that drive the SrvThreds event-driven automation system. A Pattern defines a state machine composed of **Reactions** (states) that process incoming **Events** and orchestrate complex workflows.

### Key Concepts
- **Pattern**: A workflow template that defines how events should be processed
- **Thred**: A running instance of a pattern (a state machine instance)
- **Reaction**: A state in the workflow with conditions and actions
- **Event**: A message that triggers state transitions
- **Condition**: Logic that determines if a reaction should fire
- **Transform**: Defines what new event to create
- **Publish**: Specifies who should receive the new event
- **Transition**: Determines the next state

### How Patterns Work
1. An **unbound event** (no `thredId`) arrives at the Engine
2. The Engine tests the event against all active patterns
3. Any pattern whose initial reaction matches creates a new **Thred** instance
4. The Thred processes the event through its reaction state machine
5. Successful reactions can create new events and send them to participants
6. The Thred transitions to the next reaction or terminates

---

## Core Concepts

### Pattern Lifecycle
```
Unbound Event → Pattern Matching → Thred Creation → Reaction Processing →
Event Generation → Participant Notification → State Transition → Repeat or Terminate
```

### State Persistence
- All Thred state is persisted to Redis with per-thredId locking
- State includes: current reaction, local variables, participant list, condition states
- Threds can span multiple process instances and server restarts
- Enables distributed processing and failover

### Event Types
- **Unbound Event**: Has no `thredId` - triggers pattern matching
- **Bound Event**: Has a `thredId` - routes to existing Thred
- **System Event**: Generated by transforms within the workflow
- **Broadcast Event**: Special event type propagated to all participants (when enabled)

---

## Pattern Structure

### Schema Location
Patterns must conform to the JSON schema at: `../thredlib/src/schemas/patternModel.json`

### Root Pattern Object

```json
{
  "name": "Pattern Name",
  "id": "pattern_id",
  "description": "Optional description",
  "instanceInterval": 0,
  "maxInstances": 0,
  "broadcastAllowed": false,
  "echoResponses": false,
  "reactions": [...]
}
```

### Pattern Attributes

| Attribute | Type | Required | Description |
|-----------|------|----------|-------------|
| `name` | string | **Yes** | Unique human-readable name for the pattern |
| `id` | string | No | Unique identifier (derived from name if not provided) |
| `description` | string | No | Human-readable description of the pattern's purpose |
| `instanceInterval` | number | No | Minimum milliseconds between creating new Thred instances (0 = no limit) |
| `maxInstances` | number | No | Maximum concurrent Thred instances allowed (0 = no limit) |
| `broadcastAllowed` | boolean | No | If true, participants can broadcast events to all other participants |
| `echoResponses` | boolean | No | If true, participant responses are echoed to the entire Thred |
| `reactions` | array | **Yes** | Array of Reaction objects defining the workflow states |

### Minimal Pattern Example
```json
{
  "name": "Hello World",
  "reactions": [
    {
      "condition": {
        "type": "filter",
        "xpr": "$event.type = 'hello'",
        "transform": {
          "eventDataTemplate": {
            "title": "World!"
          }
        },
        "publish": {
          "to": ["participant0"]
        }
      }
    }
  ]
}
```

---

## Reactions

A **Reaction** represents a state in the workflow state machine. Each reaction defines conditions for matching events and actions to take when matched.

### Reaction Structure

```json
{
  "name": "reaction_name",
  "description": "Optional description",
  "allowedSources": ["source1", "$group", "/regex.*/"],
  "permissions": {
    "allowedRoles": ["admin", "operator"]
  },
  "expiry": {
    "interval": 60000,
    "transition": {
      "name": "timeout_handler"
    }
  },
  "condition": {...}
}
```

### Reaction Attributes

| Attribute | Type | Required | Description |
|-----------|------|----------|-------------|
| `name` | string | No | Optional name for the reaction (auto-generated if not provided) |
| `description` | string | No | Human-readable description |
| `allowedSources` | string/array | No | Authorization: which sources can trigger this reaction |
| `permissions` | object | No | Role-based permissions (not fully implemented) |
| `expiry` | object | No | Automatic timeout and transition after specified interval |
| `condition` | object | **Yes** | The condition that must match for the reaction to fire |

### Naming Reactions
- If `name` is not provided, reactions are auto-named as `{patternName}_{index}`
- Named reactions can be referenced in transitions
- First reaction in the array is the **initial reaction** (entry point)

### Reaction Expiry
Reactions can automatically time out and transition to another state:

```json
{
  "name": "wait_for_response",
  "expiry": {
    "interval": 30000,
    "transition": {
      "name": "timeout_handler"
    }
  },
  "condition": {...}
}
```

- `interval`: Milliseconds before expiry
- `transition`: Optional transition to take on expiry (default transition if not specified)

---

## Conditions

Conditions determine if an event matches a reaction. There are three types of conditions: **filter**, **and**, and **or**.

### Filter Condition

A filter uses a JSONata expression to evaluate if an event matches.

```json
{
  "type": "filter",
  "xpr": "$event.type = 'org.example.request'",
  "description": "Optional description",
  "onTrue": {
    "xpr": "$setLocal('requestTime', $millis())"
  },
  "transform": {...},
  "publish": {...},
  "transition": {...}
}
```

**Filter Attributes:**

| Attribute | Type | Required | Description |
|-----------|------|----------|-------------|
| `type` | string | **Yes** | Must be `"filter"` |
| `xpr` | string | **Yes** | JSONata expression that returns boolean |
| `description` | string | No | Human-readable description |
| `onTrue` | object | No | Consequent expression to run when condition matches (side effects) |
| `transform` | object | No | Defines what event to create |
| `publish` | object | No | Defines who to send the event to |
| `transition` | object | No | Defines next state transition |

### And Condition

An **and** condition requires ALL operands to match (not necessarily on the same event).

```json
{
  "type": "and",
  "description": "Wait for both approval and budget",
  "operands": [
    {
      "type": "filter",
      "xpr": "$event.type = 'approval.granted'",
      "transform": {...}
    },
    {
      "type": "filter",
      "xpr": "$event.type = 'budget.allocated'"
    }
  ],
  "publish": {...},
  "transition": {...}
}
```

**And Condition Behavior:**
- Operands are evaluated in order on each incoming event
- State is maintained - once an operand matches, it stays matched
- When ALL operands have matched at least once, the and condition fires
- The transform/publish/transition from the last matching operand is used
- State persists in Redis across events

### Or Condition

An **or** condition matches when ANY operand matches.

```json
{
  "type": "or",
  "description": "Accept or reject",
  "operands": [
    {
      "type": "filter",
      "xpr": "$valueNamed('response') = 'accept'",
      "transform": {
        "eventDataTemplate": {
          "title": "Request Accepted"
        }
      },
      "transition": {
        "name": "process_request"
      }
    },
    {
      "type": "filter",
      "xpr": "$valueNamed('response') = 'reject'",
      "transform": {
        "eventDataTemplate": {
          "title": "Request Rejected"
        }
      },
      "transition": {
        "name": "$terminate"
      }
    }
  ]
}
```

**Or Condition Behavior:**
- Operands evaluated in order until one matches
- First matching operand determines the result
- Transform/publish/transition from matching operand is used
- "Deepest one wins" - operand directives override parent level

### Nested Conditions

Conditions can be nested to create complex logic:

```json
{
  "type": "and",
  "operands": [
    {
      "type": "or",
      "operands": [
        {"type": "filter", "xpr": "$event.type = 'type1'"},
        {"type": "filter", "xpr": "$event.type = 'type2'"}
      ]
    },
    {
      "type": "filter",
      "xpr": "$valueNamed('approved') = true"
    }
  ]
}
```

### onTrue Consequent

The `onTrue` consequent runs side effects when a condition matches (typically storing values):

```json
{
  "type": "filter",
  "xpr": "$event.type = 'sensor.detected'",
  "onTrue": {
    "xpr": "$setLocal('sensorData', {'id': $valueNamed('sensorId'), 'location': $valueNamed('location')})"
  }
}
```

**Important:** The first reaction in a pattern should NOT use `onTrue` with side effects because the `test()` method is called during pattern matching, which would trigger side effects prematurely.

---

## Transforms

A **Transform** defines what new event to create when a condition matches. It describes the "what" of the workflow.

### Transform Structure

```json
{
  "transform": {
    "description": "Optional description",
    "eventDataTemplate": {...},
    "meta": {
      "reXpr": "$event.id"
    }
  }
}
```

### Transform Attributes

| Attribute | Type | Required | Description |
|-----------|------|----------|-------------|
| `description` | string | No | Human-readable description |
| `eventDataTemplate` | object | No* | Template for the event data (see EventData structure) |
| `templateXpr` | string | No* | JSONata expression that returns complete EventData |
| `meta.reXpr` | string | No | JSONata expression for the `re` (reply-to) field |

*Either `eventDataTemplate` or `templateXpr` is required

### EventData Template Structure

```json
{
  "eventDataTemplate": {
    "title": "Event Title",
    "description": "Event description",
    "display": {
      "uri": "https://example.com/icon.png"
    },
    "advice": {
      "eventType": "org.example.response",
      "title": "UI Title",
      "template": {...}
    },
    "content": {
      "values": {...},
      "tasks": [...],
      "items": [...],
      "resources": [...],
      "error": {
        "message": "Error message",
        "code": 500
      }
    }
  }
}
```

### EventData Attributes

| Attribute | Type | Description |
|-----------|------|-------------|
| `title` | string | Primary title/subject of the event |
| `description` | string | Detailed description |
| `display.uri` | string | URI to display icon/image for the event |
| `advice` | object | Instructions for how clients should handle this event |
| `advice.eventType` | string | Expected response event type |
| `advice.title` | string | UI title for client display |
| `advice.template` | object | UI template structure (see Interaction Templates) |
| `content` | object | Event payload |
| `content.values` | object | Key-value data |
| `content.valuesType` | string | Optional type identifier for values |
| `content.tasks` | array | Tasks to be performed (see Event Tasks) |
| `content.items` | array | Inline content items |
| `content.resources` | array | External resource references |
| `content.error` | object | Error information if applicable |

### Using JSONata in Templates

Any string value in the template can use JSONata expressions with the `$xpr()` syntax:

```json
{
  "eventDataTemplate": {
    "title": "$xpr( 'Sensor ' & $valueNamed('sensorId') & ' detected contact' )",
    "description": "$xpr( $event.source.name & ' at ' & $local('location') )",
    "content": {
      "values": {
        "location": "$xpr( $local('sensorData').location )",
        "timestamp": "$xpr( $millis() )"
      }
    }
  }
}
```

### Template Expression (templateXpr)

For complete control, use `templateXpr` to generate the entire EventData:

```json
{
  "transform": {
    "templateXpr": "{ 'title': $event.data.title, 'content': {'values': $event.data.content.values} }"
  }
}
```

### Reply-To (reXpr)

The `meta.reXpr` sets the `re` (reply-to) field on the outbound event:

```json
{
  "transform": {
    "meta": {
      "reXpr": "$event.id"
    },
    "eventDataTemplate": {...}
  }
}
```

This creates a thread of related events, useful for tracking request/response pairs.

---

## Publish

The **Publish** specification determines who receives the new event. It describes the "who" of the workflow.

### Publish Structure

```json
{
  "publish": {
    "description": "Optional description",
    "to": ["participant1", "$group0", "org.example.agent"],
    "onPublish": {
      "xpr": "$setLocal('sentTo', $event.id)"
    }
  }
}
```

### Publish Attributes

| Attribute | Type | Required | Description |
|-----------|------|----------|-------------|
| `description` | string | No | Human-readable description |
| `to` | string/array | **Yes** | Address(es) to send the event to |
| `onPublish` | object | No | Consequent expression to run after publishing |

### Addressing

The `to` field accepts multiple address formats:

#### Direct Participant ID
```json
{"to": "participant0"}
{"to": ["participant0", "participant1"]}
```

#### Group Reference
Groups are defined in `sessions_model.json` and referenced with `$` prefix:
```json
{"to": "$group0"}
{"to": ["$operators", "$managers"]}
```

#### Agent/Service Address
```json
{"to": "org.wt.persistence"}
{"to": ["org.wt.robot", "org.wt.sensor"]}
```

#### Dynamic Addressing with JSONata
```json
{"to": "$xpr( $local('respondingParticipant') )"}
{"to": "$xpr( $content.values.assignedTo )"}
{"to": ["$xpr( $local('participants') )"]}
```

### Address Resolution

The publish system resolves addresses to participant IDs:
1. Direct participant IDs pass through unchanged
2. Group references (`$group`) expand to member participant IDs
3. Dynamic expressions are evaluated and can return strings or arrays
4. Arrays are flattened (nested arrays are expanded)
5. All resolved participants are stored in the Thred's participant list

### onPublish Consequent

The `onPublish` handler runs after the event is published, with the **outbound event** as context:

```json
{
  "publish": {
    "to": "org.wt.robot",
    "onPublish": {
      "xpr": "$setLocal('deployRequestId', $event.id)"
    }
  }
}
```

This is useful for tracking request IDs or storing information about the outbound event.

---

## Transitions

**Transitions** determine the next state (reaction) after a condition matches. They describe "where to go next" in the workflow.

### Transition Structure

```json
{
  "transition": {
    "name": "next_reaction_name",
    "input": "forward",
    "localName": "stored_event",
    "description": "Optional description"
  }
}
```

### Transition Attributes

| Attribute | Type | Required | Description |
|-----------|------|----------|-------------|
| `name` | string | **Yes** | Target reaction name or special directive |
| `input` | string | No | How to supply input to next reaction: `"default"`, `"forward"`, or `"local"` |
| `localName` | string | No* | Name of local variable containing event (required if input=`"local"`) |
| `description` | string | No | Human-readable description |

### Transition Name

The `name` field can be:

#### Named Reaction
```json
{"name": "process_approval"}
```
Transitions to the reaction with that name.

#### Special Directives

**`$next`** - Proceed to the next reaction in sequence:
```json
{"name": "$next"}
```

**`$terminate`** - End the Thred:
```json
{"name": "$terminate"}
```

**`$noTransition`** - Stay in current reaction:
```json
{"name": "$noTransition"}
```

### Transition Input Types

The `input` field controls what event the next reaction receives:

#### Default Input
```json
{"input": "default"}
```
**Default behavior** - Wait for the next matching event. The Thred becomes dormant until a new event arrives that matches the next reaction's condition.

#### Forward Input
```json
{"input": "forward"}
```
**Immediately process current event** - The event that triggered this transition is forwarded to the next reaction. The state machine continues processing synchronously.

```json
{
  "transition": {
    "name": "validate_data",
    "input": "forward"
  }
}
```

Use case: Multi-step processing of a single event.

#### Local Input
```json
{
  "input": "local",
  "localName": "stored_event"
}
```

**Use a stored event** - Retrieve an event previously stored in local storage and use it as input to the next reaction.

```json
{
  "onTrue": {
    "xpr": "$setLocal('original_request', $event)"
  },
  "transition": {
    "name": "reprocess",
    "input": "local",
    "localName": "original_request"
  }
}
```

Use case: Re-processing a previous event, implementing retry logic, or using a different event as input.

### Default Transition Behavior

If no `transition` is specified:
- By default, transitions to the **next reaction** in the array (equivalent to `{"name": "$next"}`)
- If there is no next reaction, the Thred **terminates**

---

## JSONata Expressions

SrvThreds uses [JSONata](https://jsonata.org/) for expression evaluation throughout patterns. JSONata is a lightweight query and transformation language for JSON data.

### Expression Syntax

Expressions can be used in two ways:

#### 1. In Condition Filters
```json
{
  "type": "filter",
  "xpr": "$event.type = 'example' and $valueNamed('count') > 10"
}
```

#### 2. In Templates with $xpr()
```json
{
  "title": "$xpr( 'Count: ' & $valueNamed('count') )"
}
```

The `$xpr()` directive can be:
- **Inline**: `"$xpr( expression )"` - String value starting with `$xpr(`
- **Object key**: `{"$xpr": "expression"}` - Spreads result into parent object

### Available Bindings

These variables and functions are available in all JSONata expressions:

#### Event Accessors

| Binding | Description | Example |
|---------|-------------|---------|
| `$event` | The complete event object | `$event.id` |
| `$data` | Event data section | `$data.title` |
| `$content` | Event content section | `$content.values` |
| `$values` | Shortcut to content.values | `$values.fieldName` |
| `$advice` | Event advice section | `$advice.eventType` |
| `$valueNamed(name)` | Get value by name from event | `$valueNamed('sensorId')` |

**Important**
- When targeting specific values (key names) in the event payload values object, using the $valueNamed(name) operator is of
ten the best approach.  It will search all arrays and objects in a depth-first search until it encounters the key/value you've specificed in $valueNamed(name). It will return the first occurance that it encounters.  This is often a better approac
h than trying to accurately predict the returned object and array structure.

#### Context Management

| Binding | Description | Example |
|---------|-------------|---------|
| `$local(name)` | Get value from local storage | `$local('requestTime')` |
| `$setLocal(name, value)` | Store value in local storage | `$setLocal('count', 5)` |

### Local Storage

Local storage provides persistent variables scoped to a Thred instance:

```json
{
  "onTrue": {
    "xpr": "$setLocal('sensorData', {'id': $valueNamed('sensorId'), 'lat': $valueNamed('latitude')})"
  }
}
```

Later reactions can access:
```json
{
  "xpr": "$local('sensorData').lat"
}
```

**Local storage is persisted to Redis** and survives process restarts.

### Common JSONata Operators

#### Comparison
- `=` Equal
- `!=` Not equal
- `>` `<` `>=` `<=` Numeric comparison

#### Logical
- `and` Logical AND
- `or` Logical OR
- `not()` Logical NOT

#### String Operations
- `&` Concatenation: `'Hello ' & 'World'`
- `$uppercase()`, `$lowercase()`, `$trim()`
- `$contains()`, `$substring()`

#### Numeric Operations
- `+` `-` `*` `/` `%` Arithmetic
- `$number()` Convert to number
- `$round()`, `$floor()`, `$ceil()`

#### Array Operations
- `$count(array)` Array length
- `$append(array, item)` Add to array
- `$map()`, `$filter()`, `$reduce()`
- `array[0]` Array indexing

#### JSONata Built-ins
- `$millis()` Current timestamp
- `$now()` Current date/time string
- `$exists(value)` Check if value exists
- `$type(value)` Get value type

### Expression Examples

#### Conditional Logic
```json
{
  "xpr": "$valueNamed('status') = 'approved' and $valueNamed('amount') < 1000"
}
```

#### String Manipulation
```json
{
  "title": "$xpr( 'Sensor ' & $valueNamed('sensorId') & ' detected at ' & $now() )"
}
```

#### Accessing Nested Data
```json
{
  "xpr": "$local('sensorData').location.latitude"
}
```

#### Array Operations
```json
{
  "xpr": "$content.values.availableTechnicians[0].id"
}
```

#### Complex Expressions
```json
{
  "xpr": "$count($content.values.items) > 0 ? $content.values.items[0].name : 'No items'"
}
```

#### Working with Local Storage
```json
{
  "onTrue": {
    "xpr": "$setLocal('attempts', $local('attempts') ? $local('attempts') + 1 : 1)"
  }
}
```

### Expression Best Practices

1. **Keep filters simple** - Complex logic should be broken into multiple reactions
2. **Use onTrue for side effects** - Store computed values for reuse
3. **Avoid side effects in initial reactions** - They run during pattern matching
4. **Use meaningful local variable names** - `$local('originalRequest')` not `$local('x')`
5. **Store objects for complex data** - `$setLocal('data', {...})` rather than multiple variables

---

## Event Tasks

**Tasks** provide a generic, declarative way to specify operations to be performed by external systems, agents, or APIs. Tasks are included in event content and processed by the receiving agent.

**Important:** The task system uses platform-agnostic operators and operations that are automatically translated to the appropriate implementation for the target system (MongoDB, Redis, REST APIs, etc.). This abstraction allows patterns to work across different persistence and service backends without modification.

### Task Structure

```json
{
  "content": {
    "tasks": [
      {
        "name": "task_identifier",
        "op": "put",
        "options": {
          "dbname": "production"
        },
        "params": {
          "type": "Employee",
          "matcher": {"id": "emp_123"},
          "selector": {"include": ["name", "email"]},
          "collector": {
            "limit": 10,
            "skip": 0,
            "sort": [{"field": "name", "desc": false}]
          },
          "values": {
            "status": "active"
          }
        }
      }
    ]
  }
}
```

### Task Attributes

| Attribute | Type | Required | Description |
|-----------|------|----------|-------------|
| `name` | string | No | Identifier for the task (useful for tracking) |
| `op` | string | **Yes** | Operation to perform (see Operations below) |
| `options` | object | No | Implementation-specific options |
| `params` | object | **Yes** | Parameters for the operation |

### Operations

The `op` field specifies the operation type:

| Operation | Description |
|-----------|-------------|
| `put` | Create a new record/entity |
| `getOne` | Retrieve a single record |
| `get` | Query/retrieve multiple records |
| `update` | Update existing record(s) |
| `upsert` | Update if exists, create if not |
| `replace` | Replace entire record |
| `delete` | Delete record(s) |
| `count` | Count matching records |
| `run` | Execute custom operation |

### Task Parameters

The `params` object structure:

| Parameter | Type | Description |
|-----------|------|-------------|
| `type` | string | **Required** - Type/collection/entity identifier |
| `matcher` | object | Query to match existing records (for update/delete/get) |
| `selector` | object | Field selection for query results |
| `collector` | object | Pagination and sorting options |
| `values` | object/array | Data values for create/update operations |

### Parameter Details

#### Type
Identifies the entity type, collection, or resource:
```json
{
  "type": "Employee"
}
```

#### Matcher
Query object to find existing records:
```json
{
  "matcher": {
    "id": "emp_123"
  }
}
```

With JSONata:
```json
{
  "matcher": {
    "id": "$xpr( $valueNamed('employeeId') )"
  }
}
```

#### Selector
Specify which fields to include or exclude:
```json
{
  "selector": {
    "include": ["id", "name", "email"],
    "exclude": ["password", "ssn"]
  }
}
```

#### Collector
Pagination and sorting:
```json
{
  "collector": {
    "limit": 50,
    "skip": 0,
    "sort": [
      {"field": "name", "desc": false},
      {"field": "hireDate", "desc": true}
    ]
  }
}
```

#### Values
Data for create/update operations:
```json
{
  "values": {
    "name": "John Doe",
    "email": "john@example.com",
    "status": "active"
  }
}
```

With JSONata:
```json
{
  "values": {
    "name": "$xpr( $valueNamed('employeeName') )",
    "updatedAt": "$xpr( $millis() )"
  }
}
```

### Generic Update Operators

The system provides platform-agnostic update operators that work across different persistence implementations. These operators are automatically translated to the appropriate database-specific operations (e.g., for MongoDB, Redis, etc.).

**Available Update Operators:**

| Operator | Description | Example |
|----------|-------------|---------|
| `$add` | Add value to set (unique values only) | `{"$add": {"tags": "newTag"}}` |
| `$push` | Append value to array | `{"$push": {"items": "newItem"}}` |
| `$remove` | Remove value from array | `{"$remove": {"tags": "oldTag"}}` |
| `$now` | Set field to current timestamp | `{"$now": {"lastUpdated": true}}` |
| `$inc` | Increment numeric value | `{"$inc": {"count": 1}}` |
| `$min` | Update to minimum value | `{"$min": {"lowestScore": 50}}` |
| `$max` | Update to maximum value | `{"$max": {"highestScore": 100}}` |
| `$mul` | Multiply numeric value | `{"$mul": {"quantity": 2}}` |

**Note:** Regular field assignments (without operators) are treated as set/replace operations automatically.

```json
{
  "values": {
    "status": "active",
    "$push": {
      "tags": "$xpr( $valueNamed('newTag') )"
    },
    "$inc": {
      "loginCount": 1
    }
  }
}
```

### Generic Match/Query Operators

When querying data using the `matcher` parameter, you can use these platform-agnostic comparison operators:

| Operator | Description | Example |
|----------|-------------|---------|
| `$gte` | Greater than or equal | `{"age": {"$gte": 18}}` |
| `$gt` | Greater than | `{"score": {"$gt": 90}}` |
| `$lte` | Less than or equal | `{"price": {"$lte": 100}}` |
| `$lt` | Less than | `{"temperature": {"$lt": 32}}` |
| `$ne` | Not equal | `{"status": {"$ne": "deleted"}}` |
| `$in` | Value in array | `{"role": {"$in": ["admin", "moderator"]}}` |
| `$nin` | Value not in array | `{"status": {"$nin": ["archived", "deleted"]}}` |
| `$or` | Logical OR | `{"$or": [{"status": "active"}, {"priority": "high"}]}` |
| `$not` | Logical NOT | `{"status": {"$not": {"$in": ["archived"]}}}` |
| `$re` | Regular expression match | `{"email": {"$re": ".*@example\\.com"}}` |

**Example with Match Operators:**

```json
{
  "matcher": {
    "role": "technician",
    "available": true,
    "rating": {"$gte": 4.0},
    "location": {"$in": ["north", "south"]},
    "status": {"$ne": "suspended"}
  }
}
```

### Platform Translation

The generic operators are automatically translated by the persistence layer to platform-specific implementations:

**For MongoDB:**
- `$add` → `$addToSet` (adds unique values to array)
- `$push` → `$push` (appends to array)
- `$remove` → `$pull` (removes from array)
- `$now` → `$currentDate` (sets current timestamp)
- `$inc`, `$min`, `$max`, `$mul` → map directly to MongoDB operators
- `$re` → `$regex` (regular expression matching)
- Regular field assignments are wrapped in MongoDB's `$set` operator automatically
- Match operators like `$gte`, `$lt`, `$in`, etc. map directly to MongoDB query operators

This abstraction allows the same pattern to work with different persistence backends (MongoDB, PostgreSQL, Redis, etc.) without modification. The translation happens transparently in the persistence agent.

**Example Translation:**

Pattern task definition:
```json
{
  "values": {
    "status": "active",
    "$push": {"tags": "urgent"},
    "$inc": {"priority": 1}
  }
}
```

Translates to MongoDB as:
```javascript
{
  $set: { status: "active", modified: <current_date> },
  $push: { tags: "urgent" },
  $inc: { priority: 1 }
}
```

### Task Examples

#### Create Record
```json
{
  "tasks": [
    {
      "name": "createWorkOrder",
      "op": "put",
      "params": {
        "type": "work_orders",
        "values": {
          "title": "$xpr( $local('issue').description )",
          "assignedTo": "$xpr( $valueNamed('technicianId') )",
          "createdAt": "$xpr( $millis() )"
        }
      }
    }
  ]
}
```

#### Query Records
```json
{
  "tasks": [
    {
      "name": "findAvailableTechnicians",
      "op": "get",
      "params": {
        "type": "employee",
        "selector": {
          "include": ["id", "name", "skills"]
        },
        "matcher": {
          "role": "technician",
          "available": true,
          "rating": {"$gte": 4.0},
          "location": "$xpr( $local('incident').location )",
          "status": {"$ne": "suspended"}
        },
        "collector": {
          "limit": 10,
          "sort": [{"field": "rating", "desc": true}]
        }
      }
    }
  ]
}
```

#### Update Record
```json
{
  "tasks": [
    {
      "name": "updateWorkOrder",
      "op": "update",
      "params": {
        "type": "work_orders",
        "matcher": {
          "id": "$xpr( $local('workOrderId') )"
        },
        "values": {
          "status": "in_progress",
          "startedAt": "$xpr( $millis() )",
          "assignedTo": "$xpr( $event.source.id )"
        }
      }
    }
  ]
}
```

#### Upsert with Update Operators
```json
{
  "tasks": [
    {
      "name": "trackEvent",
      "op": "upsert",
      "params": {
        "type": "metrics",
        "matcher": {
          "sensorId": "$xpr( $valueNamed('sensorId') )"
        },
        "values": {
          "$inc": {"eventCount": 1},
          "$push": {
            "events": {
              "timestamp": "$xpr( $millis() )",
              "type": "$xpr( $event.type )"
            }
          }
        }
      }
    }
  ]
}
```

#### Complex Update with Multiple Operators
Demonstrate using various update operators together:
```json
{
  "tasks": [
    {
      "name": "updateEmployeeRecord",
      "op": "update",
      "params": {
        "type": "employee",
        "matcher": {
          "id": "$xpr( $valueNamed('employeeId') )"
        },
        "values": {
          "status": "active",
          "$add": {
            "certifications": "$xpr( $valueNamed('newCertification') )"
          },
          "$push": {
            "activityLog": {
              "timestamp": "$xpr( $millis() )",
              "action": "certification_added"
            }
          },
          "$inc": {
            "totalCertifications": 1
          },
          "$now": {
            "lastModified": true
          },
          "$max": {
            "maxRating": "$xpr( $valueNamed('newRating') )"
          }
        }
      }
    }
  ]
}
```

#### Multiple Tasks
Tasks execute in sequence:
```json
{
  "tasks": [
    {
      "name": "logEvent",
      "op": "put",
      "params": {
        "type": "event_log",
        "values": {"timestamp": "$xpr($millis())"}
      }
    },
    {
      "name": "updateCounter",
      "op": "update",
      "params": {
        "type": "counters",
        "matcher": {"name": "total_events"},
        "values": {"$inc": {"count": 1}}
      }
    }
  ]
}
```

---

## Interaction Templates

**Interaction Templates** provide a generic, declarative way to describe user interfaces. Clients can render these templates in platform-appropriate ways.

### Template Structure

```json
{
  "advice": {
    "eventType": "org.example.response",
    "title": "User Prompt",
    "template": {
      "name": "template_name",
      "description": "Optional description",
      "interactions": [
        {
          "interaction": {
            "content": [...]
          }
        }
      ]
    }
  }
}
```

### Template Hierarchy

```
advice
  └─ template
      └─ interactions[]
          └─ interaction
              └─ content[]
                  └─ elements (text, input, map, image, video, group)
```

### Element Types

#### Text Element
Display text content:
```json
{
  "text": {
    "value": "Hello, World!"
  }
}
```

With JSONata:
```json
{
  "text": {
    "value": "$xpr( 'Welcome, ' & $valueNamed('userName') )"
  }
}
```

#### Input Elements

##### Boolean Input (Yes/No, True/False)
```json
{
  "input": {
    "type": "boolean",
    "name": "user_approved",
    "display": "Do you approve this request?",
    "set": [
      {"display": "Yes, approve", "value": true},
      {"display": "No, reject", "value": false}
    ]
  }
}
```

##### Numeric Input
```json
{
  "input": {
    "type": "numeric",
    "name": "quantity",
    "display": "Enter quantity:"
  }
}
```

##### Text Input
```json
{
  "input": {
    "type": "text",
    "name": "comments",
    "display": "Additional comments:"
  }
}
```

##### Nominal Input (Dropdown/Select)
```json
{
  "input": {
    "type": "nominal",
    "name": "priority",
    "display": "Select priority:",
    "multiple": false,
    "set": [
      {"display": "Low", "value": "low"},
      {"display": "Medium", "value": "medium"},
      {"display": "High", "value": "high"}
    ]
  }
}
```

With `multiple: true`, allows multiple selections.

#### Map Element
Display locations on a map:
```json
{
  "map": {
    "locations": [
      {
        "name": "Incident Location",
        "latitude": "$xpr( $local('incident').latitude )",
        "longitude": "$xpr( $local('incident').longitude )",
        "display": "https://example.com/marker-red.png"
      },
      {
        "name": "Robot Position",
        "latitude": "$xpr( $local('robot').latitude )",
        "longitude": "$xpr( $local('robot').longitude )",
        "display": "https://example.com/marker-blue.png"
      }
    ]
  }
}
```

#### Image Element
```json
{
  "image": {
    "uri": "https://example.com/image.png",
    "width": 640,
    "height": 480
  }
}
```

#### Video Element
```json
{
  "video": {
    "uri": "https://example.com/stream.mp4"
  }
}
```

Or with JSONata:
```json
{
  "video": {
    "uri": "$xpr( $local('robot').videoStreamUrl )"
  }
}
```

#### Group Element
Group multiple elements together:
```json
{
  "group": {
    "items": [
      {"text": {"value": "Header Text"}},
      {"input": {"type": "text", "name": "field1", "display": "Field 1"}},
      {"input": {"type": "text", "name": "field2", "display": "Field 2"}}
    ]
  }
}
```

### Complete Interaction Example

```json
{
  "advice": {
    "eventType": "org.example.user.response",
    "title": "Deployment Request",
    "template": {
      "name": "deployment_approval",
      "interactions": [
        {
          "interaction": {
            "content": [
              {
                "text": {
                  "value": "$xpr( 'Sensor ' & $local('sensor').id & ' detected activity' )"
                }
              },
              {
                "map": {
                  "locations": [
                    {
                      "name": "Detection Location",
                      "latitude": "$xpr( $local('sensor').latitude )",
                      "longitude": "$xpr( $local('sensor').longitude )"
                    }
                  ]
                }
              },
              {
                "input": {
                  "type": "boolean",
                  "name": "deploy_robot",
                  "display": "Deploy robot to investigate?",
                  "set": [
                    {"display": "Yes, deploy", "value": true},
                    {"display": "No, ignore", "value": false}
                  ]
                }
              }
            ]
          }
        }
      ]
    }
  }
}
```

### Capturing Input Responses

When a participant responds to an interaction, their input is sent back in an event. Access values using `$valueNamed()`:

```json
{
  "type": "filter",
  "xpr": "$event.type = 'org.example.user.response' and $valueNamed('deploy_robot') = true",
  "transform": {
    "eventDataTemplate": {
      "title": "Deploying robot..."
    }
  }
}
```

---

## Authorization

Authorization controls which sources can trigger reactions.

### allowedSources

The `allowedSources` attribute on a reaction specifies which event sources are permitted:

```json
{
  "name": "admin_only_reaction",
  "allowedSources": ["admin_user_id", "$admins", "/org\\.admin\\..*/"],
  "condition": {...}
}
```

### Source Matching Modes

#### 1. Exact Match
Direct participant ID:
```json
{
  "allowedSources": "participant_123"
}
```

Or array:
```json
{
  "allowedSources": ["participant_123", "participant_456"]
}
```

#### 2. Group Match
Groups prefixed with `$`:
```json
{
  "allowedSources": "$operators"
}
```

Resolves to all participant IDs in the group. Groups are defined in `sessions_model.json`.

#### 3. Regex Match
Regex patterns enclosed in `/`:
```json
{
  "allowedSources": ["/org\\.wt\\.robot.*/"]
}
```

Matches any source matching the regex pattern. The regex is:
- Extracted from between the `/` delimiters
- Case-insensitive (`gi` flags)
- Applied to the source ID

Examples:
- `/sensor.*/` matches `sensor1`, `sensor_abc`, etc.
- `/org\\.admin\\..*/` matches `org.admin.user1`, `org.admin.service2`, etc.

### Authorization Examples

#### Single Source
```json
{
  "allowedSources": "sensor_agent_1",
  "condition": {...}
}
```

#### Multiple Sources
```json
{
  "allowedSources": ["operator1", "operator2", "supervisor1"],
  "condition": {...}
}
```

#### Group Authorization
```json
{
  "allowedSources": "$technicians",
  "condition": {...}
}
```

#### Mixed Authorization
```json
{
  "allowedSources": [
    "admin_user",
    "$operators",
    "/org\\.wt\\.robot.*/"
  ],
  "condition": {...}
}
```

#### Agent Response Restriction
```json
{
  "name": "wait_for_persistence_response",
  "allowedSources": ["org.wt.persistence"],
  "condition": {
    "type": "filter",
    "xpr": "$event.type = 'org.wt.persistence' and $event.re = $local('requestId')"
  }
}
```

### Authorization Behavior

- If `allowedSources` is not specified, **all sources are allowed**
- If specified, the event source must match at least one allowed source
- Unauthorized events are silently rejected (no error generated)
- Authorization is checked **before** condition evaluation

### Permissions (Future)

The `permissions` attribute is defined but not fully implemented:

```json
{
  "permissions": {
    "name": "approve_work_orders",
    "description": "Can approve work orders",
    "allowedRoles": ["supervisor", "manager"]
  }
}
```

This will provide role-based access control in future versions.

---

## State Management

### Thred State

Each Thred instance maintains:
- **Current Reaction**: Which state the Thred is in
- **Local Variables**: Stored values (via `$setLocal()`)
- **Participant List**: All participants involved
- **Condition State**: For `and` conditions, tracks which operands have matched
- **Metadata**: Label, description, display URI

### State Persistence

- All state is persisted to **Redis**
- Per-thredId **locking** ensures consistency
- State survives process restarts and failovers
- Enables distributed processing across multiple Engine instances

### State Lifecycle

```
1. Thred Created → Initial state loaded
2. Event Arrives → Thred state loaded from Redis with lock
3. Process Event → State updated in memory
4. State Changes → Persisted to Redis
5. Lock Released → Other processes can access Thred
```

### Local Storage

Local variables are stored in the Thred's context:

```json
{
  "onTrue": {
    "xpr": "$setLocal('requestData', {'id': $event.id, 'timestamp': $millis()})"
  }
}
```

Access later:
```json
{
  "xpr": "$local('requestData').id"
}
```

**Best Practices:**
- Use meaningful names: `$local('originalRequest')` not `$local('x')`
- Store complex objects rather than multiple variables
- Clean up large data when no longer needed (though this is manual)

### Participant Tracking

Participants are automatically tracked:
- When events are published to them
- When they send events to the Thred
- Accessible via context (though not directly exposed in patterns currently)

### Condition State (And Conditions)

`And` conditions maintain which operands have matched:

```json
{
  "type": "and",
  "operands": [
    {"type": "filter", "xpr": "$event.type = 'approval'"},
    {"type": "filter", "xpr": "$event.type = 'budget'"}
  ]
}
```

State tracks: `[false, false]` → `[true, false]` → `[true, true]` → fires

This state is persisted and survives restarts.

---

## Complete Examples

### Example 1: Simple Request/Response

```json
{
  "name": "Simple Request Response",
  "id": "simple_request_response",
  "reactions": [
    {
      "name": "initial_request",
      "condition": {
        "type": "filter",
        "xpr": "$event.type = 'org.example.request'",
        "transform": {
          "meta": {
            "reXpr": "$event.id"
          },
          "eventDataTemplate": {
            "title": "Processing Request",
            "description": "$xpr( 'Request from ' & $event.source.name )"
          }
        },
        "publish": {
          "to": "org.example.processor"
        }
      }
    },
    {
      "name": "handle_response",
      "condition": {
        "type": "filter",
        "xpr": "$event.type = 'org.example.response'",
        "transform": {
          "eventDataTemplate": {
            "title": "Request Complete",
            "content": {
              "values": {
                "result": "$xpr( $valueNamed('result') )"
              }
            }
          }
        },
        "publish": {
          "to": "$xpr( $event.source.id )"
        },
        "transition": {
          "name": "$terminate"
        }
      }
    }
  ]
}
```

### Example 2: Multi-Step Approval Workflow

```json
{
  "name": "Approval Workflow",
  "id": "approval_workflow",
  "reactions": [
    {
      "name": "request_approval",
      "condition": {
        "type": "filter",
        "xpr": "$event.type = 'org.example.approval_request'",
        "onTrue": {
          "xpr": "$setLocal('requestData', {'requester': $event.source.id, 'amount': $valueNamed('amount'), 'description': $valueNamed('description')})"
        },
        "transform": {
          "eventDataTemplate": {
            "title": "Approval Required",
            "description": "$xpr( $local('requestData').description )",
            "advice": {
              "eventType": "org.example.approval_response",
              "title": "Please Review",
              "template": {
                "name": "approval_form",
                "interactions": [
                  {
                    "interaction": {
                      "content": [
                        {
                          "text": {
                            "value": "$xpr( 'Amount: $' & $local('requestData').amount )"
                          }
                        },
                        {
                          "input": {
                            "type": "boolean",
                            "name": "approved",
                            "display": "Approve this request?",
                            "set": [
                              {"display": "Approve", "value": true},
                              {"display": "Reject", "value": false}
                            ]
                          }
                        },
                        {
                          "input": {
                            "type": "text",
                            "name": "comments",
                            "display": "Comments:"
                          }
                        }
                      ]
                    }
                  }
                ]
              }
            }
          }
        },
        "publish": {
          "to": "$managers"
        }
      }
    },
    {
      "name": "handle_decision",
      "allowedSources": "$managers",
      "condition": {
        "type": "or",
        "operands": [
          {
            "type": "filter",
            "xpr": "$valueNamed('approved') = true",
            "onTrue": {
              "xpr": "$setLocal('approver', $event.source.id)"
            },
            "transform": {
              "eventDataTemplate": {
                "title": "Request Approved",
                "description": "$xpr( 'Approved by ' & $event.source.name )",
                "content": {
                  "values": {
                    "approved": true,
                    "approver": "$xpr( $local('approver') )",
                    "comments": "$xpr( $valueNamed('comments') )"
                  }
                }
              }
            },
            "transition": {
              "name": "process_approved"
            }
          },
          {
            "type": "filter",
            "xpr": "$valueNamed('approved') = false",
            "transform": {
              "eventDataTemplate": {
                "title": "Request Rejected",
                "description": "$xpr( 'Rejected by ' & $event.source.name )",
                "content": {
                  "values": {
                    "approved": false,
                    "comments": "$xpr( $valueNamed('comments') )"
                  }
                }
              }
            },
            "transition": {
              "name": "$terminate"
            }
          }
        ],
        "publish": {
          "to": "$xpr( $local('requestData').requester )"
        }
      }
    },
    {
      "name": "process_approved",
      "condition": {
        "type": "filter",
        "xpr": "true",
        "transform": {
          "eventDataTemplate": {
            "title": "Processing Approved Request",
            "content": {
              "tasks": [
                {
                  "name": "createRecord",
                  "op": "put",
                  "params": {
                    "type": "approved_requests",
                    "values": {
                      "requester": "$xpr( $local('requestData').requester )",
                      "approver": "$xpr( $local('approver') )",
                      "amount": "$xpr( $local('requestData').amount )",
                      "approvedAt": "$xpr( $millis() )"
                    }
                  }
                }
              ]
            }
          }
        },
        "publish": {
          "to": "org.example.processor"
        },
        "transition": {
          "name": "$terminate"
        }
      }
    }
  ]
}
```

### Example 3: Sensor Detection with Robot Deployment

```json
{
  "name": "Sensor Detection Response",
  "id": "sensor_detection",
  "reactions": [
    {
      "name": "sensor_alert",
      "allowedSources": ["/sensor.*/"],
      "condition": {
        "type": "filter",
        "xpr": "$event.type = 'sensor.detection'",
        "onTrue": {
          "xpr": "$setLocal('detection', {'sensorId': $valueNamed('sensorId'), 'latitude': $valueNamed('latitude'), 'longitude': $valueNamed('longitude'), 'timestamp': $millis()})"
        },
        "transform": {
          "eventDataTemplate": {
            "title": "Sensor Detection Alert",
            "description": "$xpr( 'Sensor ' & $local('detection').sensorId & ' detected activity' )",
            "advice": {
              "eventType": "user.response",
              "title": "Detection Alert",
              "template": {
                "name": "detection_response",
                "interactions": [
                  {
                    "interaction": {
                      "content": [
                        {
                          "map": {
                            "locations": [
                              {
                                "name": "Detection Location",
                                "latitude": "$xpr( $local('detection').latitude )",
                                "longitude": "$xpr( $local('detection').longitude )"
                              }
                            ]
                          }
                        },
                        {
                          "input": {
                            "type": "boolean",
                            "name": "deploy_robot",
                            "display": "Deploy robot to investigate?",
                            "set": [
                              {"display": "Yes, deploy", "value": true},
                              {"display": "No, ignore", "value": false}
                            ]
                          }
                        }
                      ]
                    }
                  }
                ]
              }
            }
          }
        },
        "publish": {
          "to": "$operators"
        }
      }
    },
    {
      "name": "handle_user_decision",
      "allowedSources": "$operators",
      "condition": {
        "type": "or",
        "operands": [
          {
            "type": "filter",
            "xpr": "$valueNamed('deploy_robot') = true",
            "transform": {
              "eventDataTemplate": {
                "title": "Deploy Robot",
                "content": {
                  "tasks": [
                    {
                      "name": "deployRobot",
                      "op": "update",
                      "params": {
                        "type": "Robot",
                        "matcher": {"status": "available"},
                        "values": {
                          "status": "deploying",
                          "targetLocation": {
                            "latitude": "$xpr( $local('detection').latitude )",
                            "longitude": "$xpr( $local('detection').longitude )"
                          }
                        }
                      }
                    }
                  ]
                }
              }
            },
            "publish": {
              "to": "org.example.robot",
              "onPublish": {
                "xpr": "$setLocal('deployRequestId', $event.id)"
              }
            },
            "transition": {
              "name": "wait_for_robot"
            }
          },
          {
            "type": "filter",
            "xpr": "$valueNamed('deploy_robot') = false",
            "transform": {
              "eventDataTemplate": {
                "title": "Detection Ignored",
                "description": "User chose not to investigate"
              }
            },
            "publish": {
              "to": "$operators"
            },
            "transition": {
              "name": "$terminate"
            }
          }
        ]
      }
    },
    {
      "name": "wait_for_robot",
      "allowedSources": ["/org\\.example\\.robot.*/"],
      "condition": {
        "type": "filter",
        "xpr": "$event.type = 'robot.status' and $event.re = $local('deployRequestId') and $valueNamed('status') = 'arrived'",
        "onTrue": {
          "xpr": "$setLocal('robot', {'id': $valueNamed('robotId'), 'latitude': $valueNamed('latitude'), 'longitude': $valueNamed('longitude'), 'videoUrl': $valueNamed('videoStreamUrl')})"
        },
        "transform": {
          "eventDataTemplate": {
            "title": "Robot Arrived",
            "description": "$xpr( 'Robot ' & $local('robot').id & ' has arrived at location' )",
            "advice": {
              "eventType": "user.response",
              "title": "Robot Status",
              "template": {
                "name": "robot_video",
                "interactions": [
                  {
                    "interaction": {
                      "content": [
                        {
                          "map": {
                            "locations": [
                              {
                                "name": "Detection",
                                "latitude": "$xpr( $local('detection').latitude )",
                                "longitude": "$xpr( $local('detection').longitude )"
                              },
                              {
                                "name": "Robot",
                                "latitude": "$xpr( $local('robot').latitude )",
                                "longitude": "$xpr( $local('robot').longitude )",
                                "display": "https://example.com/robot-icon.png"
                              }
                            ]
                          }
                        },
                        {
                          "video": {
                            "uri": "$xpr( $local('robot').videoUrl )"
                          }
                        }
                      ]
                    }
                  }
                ]
              }
            }
          }
        },
        "publish": {
          "to": "$operators"
        },
        "transition": {
          "name": "$terminate"
        }
      }
    }
  ]
}
```

### Example 4: And Condition with Multiple Requirements

```json
{
  "name": "Multi-Approval Process",
  "id": "multi_approval",
  "reactions": [
    {
      "name": "request_approvals",
      "condition": {
        "type": "filter",
        "xpr": "$event.type = 'approval.request'",
        "onTrue": {
          "xpr": "$setLocal('request', {'id': $event.id, 'description': $valueNamed('description')})"
        },
        "transform": {
          "eventDataTemplate": {
            "title": "Approval Needed",
            "description": "$xpr( $local('request').description )",
            "advice": {
              "eventType": "approval.response",
              "template": {
                "name": "approval_form",
                "interactions": [
                  {
                    "interaction": {
                      "content": [
                        {
                          "input": {
                            "type": "boolean",
                            "name": "approved",
                            "display": "Do you approve?",
                            "set": [
                              {"display": "Approve", "value": true},
                              {"display": "Reject", "value": false}
                            ]
                          }
                        }
                      ]
                    }
                  }
                ]
              }
            }
          }
        },
        "publish": {
          "to": ["manager1", "manager2", "director1"]
        }
      }
    },
    {
      "name": "collect_approvals",
      "condition": {
        "type": "and",
        "operands": [
          {
            "type": "filter",
            "xpr": "$event.source.id = 'manager1' and $valueNamed('approved') = true",
            "onTrue": {
              "xpr": "$setLocal('manager1_approved', true)"
            }
          },
          {
            "type": "filter",
            "xpr": "$event.source.id = 'manager2' and $valueNamed('approved') = true",
            "onTrue": {
              "xpr": "$setLocal('manager2_approved', true)"
            }
          },
          {
            "type": "filter",
            "xpr": "$event.source.id = 'director1' and $valueNamed('approved') = true",
            "onTrue": {
              "xpr": "$setLocal('director_approved', true)"
            },
            "transform": {
              "eventDataTemplate": {
                "title": "All Approvals Received",
                "description": "Request has been fully approved"
              }
            },
            "publish": {
              "to": "org.example.processor"
            },
            "transition": {
              "name": "$terminate"
            }
          }
        ]
      }
    }
  ]
}
```

### Example 5: Reaction Expiry with Timeout

```json
{
  "name": "Timeout Example",
  "id": "timeout_example",
  "reactions": [
    {
      "name": "send_request",
      "condition": {
        "type": "filter",
        "xpr": "$event.type = 'request'",
        "transform": {
          "eventDataTemplate": {
            "title": "Please Respond",
            "advice": {
              "eventType": "response",
              "template": {
                "name": "response_form",
                "interactions": [
                  {
                    "interaction": {
                      "content": [
                        {
                          "input": {
                            "type": "text",
                            "name": "answer",
                            "display": "Your response:"
                          }
                        }
                      ]
                    }
                  }
                ]
              }
            }
          }
        },
        "publish": {
          "to": "participant1"
        }
      }
    },
    {
      "name": "wait_for_response",
      "expiry": {
        "interval": 30000,
        "transition": {
          "name": "handle_timeout"
        }
      },
      "condition": {
        "type": "filter",
        "xpr": "$event.type = 'response'",
        "transform": {
          "eventDataTemplate": {
            "title": "Response Received",
            "content": {
              "values": {
                "answer": "$xpr( $valueNamed('answer') )"
              }
            }
          }
        },
        "publish": {
          "to": "$admins"
        },
        "transition": {
          "name": "$terminate"
        }
      }
    },
    {
      "name": "handle_timeout",
      "condition": {
        "type": "filter",
        "xpr": "true",
        "transform": {
          "eventDataTemplate": {
            "title": "Response Timeout",
            "description": "No response received within 30 seconds"
          }
        },
        "publish": {
          "to": "$admins"
        },
        "transition": {
          "name": "$terminate"
        }
      }
    }
  ]
}
```

---

## Best Practices

### Pattern Design

1. **Start Simple**
   - Begin with basic filter conditions
   - Add complexity incrementally
   - Test each reaction independently

2. **Name Your Reactions**
   - Use descriptive names: `wait_for_approval` not `reaction2`
   - Makes transitions and debugging easier
   - Self-documenting patterns

3. **Use Descriptions**
   - Add description fields to patterns, reactions, and conditions
   - Helps maintainability and team understanding

4. **One Responsibility Per Reaction**
   - Each reaction should have a clear purpose
   - Break complex logic into multiple reactions
   - Use transitions to chain reactions

### State Management

1. **Store What You Need**
   - Use `$setLocal()` to capture important data early
   - Store complete objects rather than multiple variables
   - Example: `$setLocal('request', {id, timestamp, data})` vs multiple setLocals

2. **Meaningful Variable Names**
   - `$local('originalRequest')` not `$local('x')`
   - Makes expressions self-documenting
   - Easier to debug

3. **Avoid Side Effects in Initial Reaction**
   - First reaction's onTrue runs during pattern matching
   - Use subsequent reactions for side effects
   - Or store data in transform instead

### Expression Guidelines

1. **Keep Expressions Simple**
   - Complex logic → multiple reactions
   - Simple expressions → easier to debug
   - JSONata can be powerful but avoid over-complexity

2. **Use onTrue for Calculations**
   - Pre-compute values for reuse
   - Example: Calculate and store, then reference in multiple places

3. **Defensive Checks**
   ```json
   "$local('data') ? $local('data').field : 'default'"
   ```

### Authorization

1. **Principle of Least Privilege**
   - Specify allowedSources where appropriate
   - Don't leave critical reactions wide open
   - Use groups for role-based access

2. **Verify Agent Responses**
   ```json
   {
     "allowedSources": ["org.wt.persistence"],
     "condition": {
       "xpr": "$event.re = $local('requestId')"
     }
   }
   ```

3. **Use Regex Carefully**
   - Test regex patterns thoroughly
   - Document what patterns match
   - Prefer specific over general

### Error Handling

1. **Plan for Timeouts**
   - Use expiry for time-sensitive reactions
   - Provide fallback transitions

2. **Handle Rejection Cases**
   - Use `or` conditions for accept/reject scenarios
   - Always provide a path forward or termination

3. **Validate Input**
   ```json
   "$exists($valueNamed('required_field'))"
   ```

### Performance

1. **Minimize State Size**
   - Don't store entire events if you only need a few fields
   - Clean up large data structures when done

2. **Use Specific Filters**
   - `$event.type = 'specific.type'` is fast
   - Complex calculations in filters can be slow

3. **Limit Participant Lists**
   - Large participant lists consume memory
   - Consider archiving or limiting scope

### Testing

1. **Test Pattern Matching**
   - Verify initial reaction matches expected events
   - Test with various event types

2. **Test State Transitions**
   - Verify each reaction transitions correctly
   - Test termination conditions

3. **Test Authorization**
   - Verify allowedSources work as expected
   - Test with unauthorized sources

4. **Test Edge Cases**
   - Timeouts
   - Missing data
   - Unexpected event sequences

### Documentation

1. **Document Complex Patterns**
   - Add comments in a separate doc
   - Diagram workflow states
   - Provide example event sequences

2. **Version Patterns**
   - Use pattern IDs to distinguish versions
   - Document changes between versions

3. **Share Examples**
   - Build a library of pattern templates
   - Document common workflows

---

## AI Agent Guidelines

This section provides guidance for AI agents generating patterns from natural language instructions.

### Understanding Requirements

When given a workflow description, identify:

1. **Trigger Events**: What starts the workflow?
2. **States**: What are the distinct steps?
3. **Decision Points**: Where does logic branch?
4. **Participants**: Who is involved?
5. **Data Flow**: What information is captured and passed?
6. **Termination**: How does the workflow end?

### Pattern Generation Strategy

#### Step 1: Identify Reactions

Convert workflow steps into reactions:

**User Request:**
"When a sensor detects something, notify operators. If they approve, deploy a robot."

**Reactions:**
1. `sensor_detection` - Initial trigger
2. `wait_for_operator_approval` - User decision
3. `deploy_robot` - Action

#### Step 2: Define Conditions

For each reaction, determine:
- Event type to match
- Required data fields
- Authorization constraints

```json
{
  "name": "sensor_detection",
  "condition": {
    "type": "filter",
    "xpr": "$event.type = 'sensor.detection'"
  }
}
```

#### Step 3: Identify State Storage

What data needs to be preserved?

```json
{
  "onTrue": {
    "xpr": "$setLocal('sensorData', {'id': $valueNamed('sensorId'), 'location': $valueNamed('location')})"
  }
}
```

#### Step 4: Design Transforms

What events should be created?

```json
{
  "transform": {
    "eventDataTemplate": {
      "title": "Sensor Alert",
      "description": "$xpr( 'Sensor detected at ' & $local('sensorData').location )"
    }
  }
}
```

#### Step 5: Specify Recipients

Who should receive events?

```json
{
  "publish": {
    "to": "$operators"
  }
}
```

#### Step 6: Define Transitions

How should the workflow progress?

```json
{
  "transition": {
    "name": "wait_for_operator_approval"
  }
}
```

### Common Workflow Patterns

#### Request/Response
```
Initial Event → Send Request → Wait for Response → Process Response → Terminate
```

#### Approval Workflow
```
Request → Notify Approver → Wait for Decision → [Approved: Process | Rejected: Terminate]
```

#### Multi-Step Process
```
Step 1 → Step 2 → Step 3 → ... → Terminate
(Use input: "forward" for synchronous steps)
```

#### Multi-Approval (And)
```
Request → Send to Multiple Approvers → Wait for All → Process → Terminate
```

#### Branching (Or)
```
Event → Decision Point → [Path A | Path B | Path C] → Continue or Terminate
```

#### Timeout Pattern
```
Send Request → Wait with Expiry → [Response: Process | Timeout: Handle Timeout]
```

### Natural Language to Pattern Translation

#### Example 1: "Send a notification when X happens"

```json
{
  "name": "Notify on X",
  "reactions": [
    {
      "condition": {
        "type": "filter",
        "xpr": "$event.type = 'X.happened'",
        "transform": {
          "eventDataTemplate": {
            "title": "X Happened",
            "description": "Notification about X"
          }
        },
        "publish": {
          "to": ["target_participant"]
        },
        "transition": {
          "name": "$terminate"
        }
      }
    }
  ]
}
```

#### Example 2: "Get approval from user A, then notify user B"

```json
{
  "name": "Approval Then Notify",
  "reactions": [
    {
      "name": "request_approval",
      "condition": {
        "type": "filter",
        "xpr": "$event.type = 'approval.needed'",
        "transform": {
          "eventDataTemplate": {
            "title": "Approval Required",
            "advice": {
              "eventType": "approval.response",
              "template": {
                "name": "approval_form",
                "interactions": [{
                  "interaction": {
                    "content": [{
                      "input": {
                        "type": "boolean",
                        "name": "approved",
                        "display": "Approve?",
                        "set": [
                          {"display": "Yes", "value": true},
                          {"display": "No", "value": false}
                        ]
                      }
                    }]
                  }
                }]
              }
            }
          }
        },
        "publish": {
          "to": "userA"
        }
      }
    },
    {
      "name": "notify_user_b",
      "condition": {
        "type": "filter",
        "xpr": "$valueNamed('approved') = true",
        "transform": {
          "eventDataTemplate": {
            "title": "Approval Received",
            "description": "User A has approved"
          }
        },
        "publish": {
          "to": "userB"
        },
        "transition": {
          "name": "$terminate"
        }
      }
    }
  ]
}
```

#### Example 3: "Wait for both manager and director approval"

```json
{
  "name": "Dual Approval",
  "reactions": [
    {
      "name": "request_approvals",
      "condition": {
        "type": "filter",
        "xpr": "$event.type = 'approval.request'",
        "transform": {
          "eventDataTemplate": {
            "title": "Approval Needed",
            "advice": {
              "eventType": "approval.response",
              "template": {
                "name": "approval_form",
                "interactions": [{
                  "interaction": {
                    "content": [{
                      "input": {
                        "type": "boolean",
                        "name": "approved",
                        "display": "Approve?",
                        "set": [
                          {"display": "Approve", "value": true},
                          {"display": "Reject", "value": false}
                        ]
                      }
                    }]
                  }
                }]
              }
            }
          }
        },
        "publish": {
          "to": ["manager", "director"]
        }
      }
    },
    {
      "name": "collect_approvals",
      "condition": {
        "type": "and",
        "operands": [
          {
            "type": "filter",
            "xpr": "$event.source.id = 'manager' and $valueNamed('approved') = true"
          },
          {
            "type": "filter",
            "xpr": "$event.source.id = 'director' and $valueNamed('approved') = true",
            "transform": {
              "eventDataTemplate": {
                "title": "Both Approvals Received"
              }
            },
            "publish": {
              "to": "system.processor"
            },
            "transition": {
              "name": "$terminate"
            }
          }
        ]
      }
    }
  ]
}
```

### Validation Checklist

When generating a pattern, verify:

- [ ] Pattern has `name` and `reactions` array
- [ ] First reaction is the entry point (matches initial event)
- [ ] Each reaction has a `condition` with `type` and required fields
- [ ] Filter conditions have `xpr` field
- [ ] And/Or conditions have `operands` array
- [ ] Transforms have either `eventDataTemplate` or `templateXpr`
- [ ] Publish specs have `to` field
- [ ] Transitions reference valid reaction names or special directives
- [ ] Input types (`forward`, `local`) used appropriately
- [ ] Local variables set before use
- [ ] Appropriate authorization with `allowedSources`
- [ ] Workflow has clear termination conditions
- [ ] All JSONata expressions use valid syntax
- [ ] All `$xpr()` directives properly formatted

### Common Mistakes to Avoid

1. **Missing Initial Reaction**
   - First reaction must match the triggering event

2. **Undefined Transition Targets**
   - All named transitions must reference existing reactions

3. **Local Variables Not Set**
   - Reference to `$local('x')` without prior `$setLocal('x', ...)`

4. **Invalid JSONata Syntax**
   - Test expressions or use established patterns

5. **Missing Required Fields**
   - condition.type, condition.xpr (for filters), publish.to

6. **Incorrect Input Types**
   - Using `input: "local"` without `localName`

7. **Side Effects in Initial Reaction**
   - Avoid `onTrue` in the first reaction

8. **No Termination Path**
   - Workflows should have clear ending points

9. **Circular Transitions**
   - Without exit conditions, creates infinite loops

10. **Mixing String/Object $xpr Syntax**
    - `"$xpr( expr )"` for strings, `{"$xpr": "expr"}` for objects

### Example: Complete AI-Generated Pattern

**User Request:** "When a work order is created, find available technicians. Show them the work order details with a map. If they accept, assign the work order to them and notify the requester."

**Generated Pattern:**

```json
{
  "name": "Work Order Assignment",
  "id": "work_order_assignment",
  "description": "Assigns work orders to available technicians",
  "reactions": [
    {
      "name": "work_order_created",
      "description": "Initial work order creation event",
      "condition": {
        "type": "filter",
        "xpr": "$event.type = 'work_order.created'",
        "description": "Match work order creation events",
        "onTrue": {
          "xpr": "$setLocal('workOrder', {'id': $valueNamed('workOrderId'), 'description': $valueNamed('description'), 'location': {'lat': $valueNamed('latitude'), 'lon': $valueNamed('longitude')}, 'requester': $event.source.id})"
        },
        "transform": {
          "description": "Query for available technicians",
          "eventDataTemplate": {
            "title": "Find Available Technicians",
            "content": {
              "tasks": [
                {
                  "name": "findTechnicians",
                  "op": "get",
                  "params": {
                    "type": "technician",
                    "selector": {
                      "include": ["id", "name", "skills"]
                    },
                    "matcher": {
                      "available": true,
                      "location": "$xpr( $local('workOrder').location )"
                    },
                    "collector": {
                      "limit": 5,
                      "sort": [{"field": "rating", "desc": true}]
                    }
                  }
                }
              ]
            }
          }
        },
        "publish": {
          "to": "system.technician_service"
        }
      }
    },
    {
      "name": "notify_technician",
      "description": "Send work order details to first available technician",
      "allowedSources": ["system.technician_service"],
      "condition": {
        "type": "filter",
        "xpr": "$event.type = 'technician.query.response' and $count($valueNamed('technicians')) > 0",
        "description": "Technicians found",
        "onTrue": {
          "xpr": "$setLocal('availableTechnicians', $valueNamed('technicians'))"
        },
        "transform": {
          "eventDataTemplate": {
            "title": "Work Order Available",
            "description": "$xpr( $local('workOrder').description )",
            "advice": {
              "eventType": "technician.response",
              "title": "Accept Work Order?",
              "template": {
                "name": "work_order_offer",
                "interactions": [
                  {
                    "interaction": {
                      "content": [
                        {
                          "text": {
                            "value": "$xpr( 'Work Order: ' & $local('workOrder').description )"
                          }
                        },
                        {
                          "map": {
                            "locations": [
                              {
                                "name": "Work Site",
                                "latitude": "$xpr( $local('workOrder').location.lat )",
                                "longitude": "$xpr( $local('workOrder').location.lon )"
                              }
                            ]
                          }
                        },
                        {
                          "input": {
                            "type": "boolean",
                            "name": "accepted",
                            "display": "Accept this work order?",
                            "set": [
                              {"display": "Accept", "value": true},
                              {"display": "Decline", "value": false}
                            ]
                          }
                        }
                      ]
                    }
                  }
                ]
              }
            }
          }
        },
        "publish": {
          "to": "$xpr( $local('availableTechnicians')[0].id )"
        }
      }
    },
    {
      "name": "handle_technician_response",
      "description": "Process technician's accept/decline decision",
      "condition": {
        "type": "or",
        "operands": [
          {
            "type": "filter",
            "xpr": "$event.type = 'technician.response' and $valueNamed('accepted') = true",
            "description": "Technician accepted",
            "onTrue": {
              "xpr": "$setLocal('assignedTechnician', {'id': $event.source.id, 'name': $event.source.name})"
            },
            "transform": {
              "eventDataTemplate": {
                "title": "Assign Work Order",
                "content": {
                  "tasks": [
                    {
                      "name": "assignWorkOrder",
                      "op": "update",
                      "params": {
                        "type": "work_order",
                        "matcher": {
                          "id": "$xpr( $local('workOrder').id )"
                        },
                        "values": {
                          "assignedTo": "$xpr( $local('assignedTechnician').id )",
                          "status": "assigned",
                          "assignedAt": "$xpr( $millis() )"
                        }
                      }
                    }
                  ]
                }
              }
            },
            "publish": {
              "to": "system.work_order_service"
            },
            "transition": {
              "name": "notify_requester"
            }
          },
          {
            "type": "filter",
            "xpr": "$event.type = 'technician.response' and $valueNamed('accepted') = false",
            "description": "Technician declined - try next one",
            "transform": {
              "eventDataTemplate": {
                "title": "Work Order Available",
                "description": "$xpr( $local('workOrder').description )",
                "advice": {
                  "eventType": "technician.response",
                  "title": "Accept Work Order?",
                  "template": {
                    "name": "work_order_offer",
                    "interactions": [
                      {
                        "interaction": {
                          "content": [
                            {
                              "text": {
                                "value": "$xpr( 'Work Order: ' & $local('workOrder').description )"
                              }
                            },
                            {
                              "map": {
                                "locations": [
                                  {
                                    "name": "Work Site",
                                    "latitude": "$xpr( $local('workOrder').location.lat )",
                                    "longitude": "$xpr( $local('workOrder').location.lon )"
                                  }
                                ]
                              }
                            },
                            {
                              "input": {
                                "type": "boolean",
                                "name": "accepted",
                                "display": "Accept this work order?",
                                "set": [
                                  {"display": "Accept", "value": true},
                                  {"display": "Decline", "value": false}
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                }
              }
            },
            "publish": {
              "to": "$xpr( $count($local('availableTechnicians')) > 1 ? $local('availableTechnicians')[1].id : 'system.admin' )"
            },
            "transition": {
              "name": "$noTransition"
            }
          }
        ]
      }
    },
    {
      "name": "notify_requester",
      "description": "Notify the original requester that work order is assigned",
      "condition": {
        "type": "filter",
        "xpr": "true",
        "transform": {
          "eventDataTemplate": {
            "title": "Work Order Assigned",
            "description": "$xpr( 'Work order has been assigned to ' & $local('assignedTechnician').name )"
          }
        },
        "publish": {
          "to": "$xpr( $local('workOrder').requester )"
        },
        "transition": {
          "name": "$terminate"
        }
      }
    }
  ]
}
```

This pattern demonstrates:
- Clear reaction progression
- State storage and retrieval
- Task generation for external systems
- User interaction templates
- Branching logic (or condition)
- Authorization constraints
- Proper termination

---

## Summary

Patterns are the core of the SrvThreds workflow automation system. By understanding:
- **Structure**: How patterns and reactions are organized
- **Conditions**: How to match events (filter, and, or)
- **Transforms**: How to create new events
- **Publish**: How to route events to participants
- **Transitions**: How to navigate workflow states
- **JSONata**: How to use expressions throughout
- **Tasks**: How to integrate with external systems
- **Templates**: How to create user interactions
- **Authorization**: How to secure workflows
- **State**: How data persists across events

You can create sophisticated, declarative workflows that orchestrate complex business processes, integrate multiple systems, and provide rich user interactions—all through JSON configuration files.

For questions, examples, or clarifications, refer to:
- Schema: `../thredlib/src/schemas/patternModel.json`
- Examples: `run-profiles/dev/patterns/`
- Code: `src/ts/engine/Pattern.ts`, `Reaction.ts`, `Condition.ts`, etc.

Happy pattern authoring!
